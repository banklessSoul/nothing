<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Ô∏é Ô∏é</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            border: none;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #666;
            font-size: 14px;
            z-index: 10;
        }
        
        /* Tweet popup styles */
        .tweet-popup {
            position: absolute;
            background-color: rgba(20, 20, 20, 0.9);
            border-radius: 10px;
            padding: 15px;
            max-width: 400px;
            width: calc(100% - 40px); /* Responsive width */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            color: #eee;
            font-size: 14px;
            line-height: 1.4;
            z-index: 100;
            display: none;
            border: 1px solid #333;
        }
        
        /* Responsive styles */
        @media (max-width: 768px) {
            .tweet-popup {
                max-width: 300px;
                padding: 10px;
            }
            
            .social-logo {
                width: 32px;
                height: 32px;
            }
            
            .x-logo {
                left: 50%;
            }
            
            .dex-logo {
                left: calc(50% + 40px);
            }
            
            .eth-logo {
                left: calc(50% - 40px);
            }
        }
        
        .tweet-popup .tweet-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .tweet-popup .profile-pic {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .tweet-popup .user-info {
            flex-grow: 1;
        }
        
        .tweet-popup .name {
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .tweet-popup .username {
            color: #999;
        }
        
        .tweet-popup .content {
            margin-bottom: 10px;
        }
        
        .tweet-popup .timestamp {
            color: #999;
            font-size: 12px;
        }
        
        .tweet-popup .twitter-logo {
            width: 20px;
            height: 20px;
            margin-left: auto;
        }
        
        /* Social links at bottom */
        .social-logo {
            position: fixed;
            bottom: 20px;
            width: 40px;
            height: 40px;
            z-index: 50;
            opacity: 0.7;
            transition: all 0.3s ease;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
        }
        
        /* Footer area - keep this space clear */
        .footer-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px; /* Height of the footer area to keep clear */
            z-index: 40;
            pointer-events: none; /* Allow clicks to pass through */
        }
        
        .social-logo:hover {
            opacity: 1;
            transform: scale(1.1);
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
        }
        
        .x-logo {
            left: 50%;
            transform: translateX(-50%);
        }
        
        .x-logo:hover {
            transform: translateX(-50%) scale(1.1);
        }
        
        .dex-logo {
            left: calc(50% + 50px);
            transform: translateX(-50%);
            bottom: 20px; /* Ensure it's at the same height as the X logo */
        }
        
        .dex-logo:hover {
            transform: translateX(-50%) scale(1.1);
        }
        
        .eth-logo {
            left: calc(50% - 50px);
            transform: translateX(-50%);
            bottom: 20px; /* Ensure it's at the same height as the X logo */
        }
        
        .eth-logo:hover {
            transform: translateX(-50%) scale(1.1);
        }
    </style>
</head>
<body>
    <div class="info"> Ô∏é Ô∏é</div>
    <canvas id="blackHoleCanvas"></canvas>
    <div class="footer-area"></div>
    
    <!-- Social links -->
    <a href="https://x.com/i/communities/1847401123151564807" target="_blank" class="social-logo x-logo">
        <svg viewBox="0 0 24 24" fill="#ffffff">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
    </a>
    
    <a href="https://dexscreener.com/solana/a4wp7fqicqztidakcxvdnzycuzjjcabyjdca7wmoqa1g" target="_blank" class="social-logo dex-logo">
        <svg viewBox="0 0 252 252" fill="#ffffff"><path d="M151.818 106.866c9.177-4.576 20.854-11.312 32.545-20.541 2.465 5.119 2.735 9.586 1.465 13.193-.9 2.542-2.596 4.753-4.826 6.512-2.415 1.901-5.431 3.285-8.765 4.033-6.326 1.425-13.712.593-20.419-3.197m1.591 46.886l12.148 7.017c-24.804 13.902-31.547 39.716-39.557 64.859-8.009-25.143-14.753-50.957-39.556-64.859l12.148-7.017a5.95 5.95 0 003.84-5.845c-1.113-23.547 5.245-33.96 13.821-40.498 3.076-2.342 6.434-3.518 9.747-3.518s6.671 1.176 9.748 3.518c8.576 6.538 14.934 16.951 13.821 40.498a5.95 5.95 0 003.84 5.845zM126 0c14.042.377 28.119 3.103 40.336 8.406 8.46 3.677 16.354 8.534 23.502 14.342 3.228 2.622 5.886 5.155 8.814 8.071 7.897.273 19.438-8.5 24.796-16.709-9.221 30.23-51.299 65.929-80.43 79.589-.012-.005-.02-.012-.029-.018-5.228-3.992-11.108-5.988-16.989-5.988s-11.76 1.996-16.988 5.988c-.009.005-.017.014-.029.018-29.132-13.66-71.209-49.359-80.43-79.589 5.357 8.209 16.898 16.982 24.795 16.709 2.929-2.915 5.587-5.449 8.814-8.071C69.31 16.94 77.204 12.083 85.664 8.406 97.882 3.103 111.959.377 126 0m-25.818 106.866c-9.176-4.576-20.854-11.312-32.544-20.541-2.465 5.119-2.735 9.586-1.466 13.193.901 2.542 2.597 4.753 4.826 6.512 2.416 1.901 5.432 3.285 8.766 4.033 6.326 1.425 13.711.593 20.418-3.197"></path><path d="M197.167 75.016c6.436-6.495 12.107-13.684 16.667-20.099l2.316 4.359c7.456 14.917 11.33 29.774 11.33 46.494l-.016 26.532.14 13.754c.54 33.766 7.846 67.929 24.396 99.193l-34.627-27.922-24.501 39.759-25.74-24.231L126 299.604l-41.132-66.748-25.739 24.231-24.501-39.759L0 245.25c16.55-31.264 23.856-65.427 24.397-99.193l.14-13.754-.016-26.532c0-16.721 3.873-31.578 11.331-46.494l2.315-4.359c4.56 6.415 10.23 13.603 16.667 20.099l-2.01 4.175c-3.905 8.109-5.198 17.176-2.156 25.799 1.961 5.554 5.54 10.317 10.154 13.953 4.48 3.531 9.782 5.911 15.333 7.161 3.616.814 7.3 1.149 10.96 1.035-.854 4.841-1.227 9.862-1.251 14.978L53.2 160.984l25.206 14.129a41.926 41.926 0 015.734 3.869c20.781 18.658 33.275 73.855 41.861 100.816 8.587-26.961 21.08-82.158 41.862-100.816a41.865 41.865 0 015.734-3.869l25.206-14.129-32.665-18.866c-.024-5.116-.397-10.137-1.251-14.978 3.66.114 7.344-.221 10.96-1.035 5.551-1.25 10.854-3.63 15.333-7.161 4.613-3.636 8.193-8.399 10.153-13.953 3.043-8.623 1.749-17.689-2.155-25.799l-2.01-4.175z"></path></svg>
    </a>
    
    <!-- Tweet popup container - empty structure that will be populated dynamically -->
    <div class="tweet-popup" id="tweetPopup">
        <div class="tweet-header">
            <img class="profile-pic" id="tweetProfilePic" src="" alt="Profile Picture">
            <div class="user-info">
                <div class="name" id="tweetName"></div>
                <div class="username" id="tweetUsername"></div>
            </div>
        </div>
        <div class="content" id="tweetContent"></div>
        <div class="timestamp" id="tweetTimestamp"></div>
    </div>

    <script>
        const canvas = document.getElementById('blackHoleCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Wormhole properties
        const wormhole = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 10,
            maxRadius: Math.min(canvas.width, canvas.height) * 0.2
        };
        
        // Particle system
        const particles = [];
        const maxParticles = 15000;
        let particleCount = 0; // Track current number of particles
        
        // Particle creation interval
        const particleCreationRate = 3000; // Particles per second
        let lastParticleTime = 0;
        
        // Interactive profile image dots
        const coloredDots = [];
        // Number of dots equals number of tweets
        
        // White color for all dots
        const dotColor = '#ffffff';
        
        // Tweet data array - can easily add more tweets
        const tweetsData = [
            {
                id: '1324533296357888000',
                url: 'https://x.com/SHL0MS/status/1324533296357888000',
                content: " Ô∏é Ô∏é",
                author: 'íê™',
                username: '@SHL0MS',
                timestamp: 'Nov 5, 2020',
                type: 'origin',
                profilePic: 'https://pbs.twimg.com/profile_images/1920126904994082816/EBFBcYtO_400x400.png'
            },
            {
                id: '1854947335651872886',
                url: 'https://x.com/god/status/1854947335651872886',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'God',
                username: '@god',
                timestamp: 'Nov 8, 2024',
                profilePic: 'https://pbs.twimg.com/profile_images/1880403110893400065/iMwI-2m-_400x400.jpg'
            },
            {
                id: '1864346641110601786',
                url: 'https://x.com/s8n/status/1864346641110601786',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'Satan',
                username: '@s8n',
                timestamp: 'Dec 4, 2024',
                profilePic: 'https://pbs.twimg.com/profile_images/1880278672222916608/xIG6V6Rn_400x400.jpg'
            },
            {
                id: '1943473467090985343',
                url: 'https://x.com/RaydiumProtocol/status/1943473467090985343',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'Raydium',
                username: '@RaydiumProtocol',
                timestamp: 'Jul 10, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1742621757230678016/_Av2hYEY_400x400.jpg'
            },
            {
                id: '1946985883535634688',
                url: 'https://x.com/thegreatola/status/1946985883535634688',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'Ola Œûlixir',
                username: '@thegreatola',
                timestamp: 'Jul 20, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1945817318388305920/hrVc8K5f_400x400.jpg'
            },
            {
                id: '1947213250682101783',
                url: 'https://x.com/user0000O0/status/1947213250682101783',
                content: "Ô∏é Ô∏é Ô∏é",
                author: '&rlm;',
                username: '@user0000O0',
                timestamp: 'Jul 21, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1842335199184515072/Ll2z_0VH_400x400.jpg'
            },
            {
                id: '1500876602569232384',
                url: 'https://x.com/slvppy/status/1500876602569232384',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'Slap',
                username: '@slvppy',
                timestamp: 'July 23, 2024',
                profilePic: 'https://pbs.twimg.com/profile_images/1478227815333969920/4lTpR0An_400x400.jpg'
            },
            {
                id: '1953264656803365256',
                url: 'https://x.com/PleasrDAO/status/1953264656803365256',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'Pleasr',
                username: '@PleasrDAO',
                timestamp: 'Aug 6, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1893093825473613824/yYqAO0Nl_400x400.jpg'
            },
            {
                id: '1907162255336366243',
                url: 'https://x.com/cb_doge/status/1907162255336366243',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'DogeDesigner',
                username: '@cb_doge',
                timestamp: 'Apr 1, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1498070100393754625/C2V-fbll_400x400.jpg'
            },
            {
                id: '1946256901878259764',
                url: 'https://x.com/VorosTwins/status/1946256901878259764',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'DA VINKI',
                username: '@VorosTwins',
                timestamp: 'Jul 18, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1484161306512920576/PE8QqPge_400x400.jpg'
            },
            {
                id: '1940773250520527129',
                url: 'https://x.com/LostMemeArchive/status/1940773250520527129',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'Lost Meme Archive',
                username: '@LostMemeArchive',
                timestamp: 'Jul 3, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1914120748567785472/ffFpNobt_400x400.png'
            },
            {
                id: '1953923375010918403',
                url: 'https://x.com/Cyb4rAnG3L/status/1953923375010918403',
                content: "Ô∏é Ô∏é Ô∏é",
                author: 'üêà‚Äç‚¨õ',
                username: '@Cyb4rAnG3L',
                timestamp: 'Aug 8, 2025',
                profilePic: 'https://pbs.twimg.com/profile_images/1938321133884813312/BU8hdbr__400x400.jpg'
            }
        ];
        
        // Animation speed control - slowed down by 2x
        const speedFactor = 0.15; // Original was 0.3, now half speed
        
        class Particle {
            constructor() {
                this.reset();
            }
            
            reset() {
                // Randomly distribute particles across the entire screen
                this.x = Math.random() * canvas.width*1.5;
                this.y = Math.random() * canvas.height*1.5;
                
                // Calculate angle and distance from center
                const dx = this.x - wormhole.x;
                const dy = this.y - wormhole.y;
                this.angle = Math.atan2(dy, dx);
                this.distance = Math.sqrt(dx * dx + dy * dy);
                
                // Velocity toward center with slight spiral
                // Speed depends on distance - farther particles move faster initially
                const speed = 0.3 + Math.random() * 1.0 + (this.distance / canvas.width) * 2;
                const spiralSpeed = 0.01 + Math.random() * 0.02;
                
                // Direction toward center
                this.vx = (wormhole.x - this.x) / this.distance * speed;
                this.vy = (wormhole.y - this.y) / this.distance * speed;
                this.spiralSpeed = spiralSpeed;
                
                // Clear trail when resetting
                this.trail = [];
                
                // Particle properties
                this.size = Math.random() * 2 + 1.5;
                this.opacity = 0.4 + Math.random() * 0.6;
                this.life = 1.0;
                this.decay = 0.002 + Math.random() * 0.003;
                
                // Trail
                this.trail = [];
                this.maxTrailLength = Math.floor(8 + Math.random() * 15);
            }
            
            update() {
                // Calculate distance to center
                const dx = wormhole.x - this.x;
                const dy = wormhole.y - this.y;
                const distToCenter = Math.sqrt(dx * dx + dy * dy);
                
                // Apply spiral motion
                this.angle += this.spiralSpeed;
                
                // Move toward center with increasing speed as it gets closer
                const pullStrength = Math.max(0.1, 200 / Math.max(10, distToCenter));
                this.vx += (dx / distToCenter) * pullStrength * 0.02;
                this.vy += (dy / distToCenter) * pullStrength * 0.02;
                
                // Add spiral component
                this.vx += Math.cos(this.angle + Math.PI / 2) * 0.3;
                this.vy += Math.sin(this.angle + Math.PI / 2) * 0.3;
                
                // Update position
                this.x += this.vx * speedFactor;
                this.y += this.vy * speedFactor;
                
                // Scale size based on distance to center (perspective effect)
                const sizeFactor = Math.max(0.1, Math.min(1, distToCenter / wormhole.maxRadius));
                this.currentSize = this.size * sizeFactor;
                
                // Adjust opacity based on distance - fade out as it approaches center
                if (distToCenter < wormhole.radius * 15) {
                    // Fade out as it gets very close to center
                    this.currentOpacity = this.opacity * (distToCenter / (wormhole.radius * 15));
                } else {
                    this.currentOpacity = this.opacity * Math.min(1, distToCenter / 50);
                }
                
                // Add to trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Age particle
                this.life -= this.decay;
                
                // When particles reach the center or die, remove them
                if (distToCenter < wormhole.radius || this.life <= 0) {
                    return false; // Signal to remove this particle
                }
                
                // Reset if outside screen bounds
                if (this.x < -50 || this.x > canvas.width *2 || 
                    this.y < -50 || this.y > canvas.height *2) {
                    this.reset();
                }
                
                return true; // Keep this particle
            }
            
            draw() {
                // Draw trail
                if (this.trail.length > 1) {
                    ctx.strokeStyle = `rgba(150, 150, 150, ${this.currentOpacity * 0.4 * this.life})`;
                    ctx.lineWidth = Math.max(0.5, this.currentSize * 0.3);
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    
                    ctx.stroke();
                }
                
                // Draw particle
                ctx.fillStyle = `rgba(180, 180, 180, ${this.currentOpacity * this.life})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentSize * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Initialize particles - start with a smaller batch
        function initParticles() {
            // Start with 20% of max particles
            const initialParticles = Math.floor(maxParticles * 0.2);
            
            for (let i = 0; i < initialParticles; i++) {
                particles.push(new Particle());
            }
            
            particleCount = initialParticles;
            lastParticleTime = performance.now();
        }
        
        // Draw wormhole structure
        function drawWormholeStructure() {
            // Draw concentric circles to show the tunnel structure
            const numRings = 15;
            for (let i = 1; i <= numRings; i++) {
                const radius = (wormhole.maxRadius / numRings) * i;
                const opacity = 0.1 * (1 - i / numRings);
                
                ctx.strokeStyle = `rgba(120, 120, 120, ${opacity})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(wormhole.x, wormhole.y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            
            // Update wormhole properties
            wormhole.x = canvas.width / 2;
            wormhole.y = canvas.height / 2;
            wormhole.maxRadius = Math.min(canvas.width, canvas.height) * 0.4;
            
            // Update position of origin dots
            coloredDots.forEach(dot => {
                if (dot.isOrigin) {
                    dot.x = wormhole.x;
                    dot.y = wormhole.y;
                }
            });
        });
        
        // Create new particles at regular intervals
        function addNewParticles(currentTime) {
            // Calculate time since last particle creation
            const deltaTime = currentTime - lastParticleTime;
            
            // Calculate how many particles to add based on time passed
            const particlesToAdd = Math.floor(particleCreationRate * deltaTime / 1000);
            
            if (particlesToAdd > 0) {
                // Add new particles
                for (let i = 0; i < particlesToAdd; i++) {
                    if (particleCount < maxParticles) {
                        const particle = new Particle();
                        particles.push(particle);
                        particleCount++;
                    }
                }
                
                // Update last particle time
                lastParticleTime = currentTime;
            }
        }
        
        // Animation loop
        function animate(currentTime) {
            // Add new particles at regular intervals
            addNewParticles(currentTime);
            
            // Clear canvas with black background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Keep wormhole centered
            wormhole.x = canvas.width / 2;
            wormhole.y = canvas.height / 2;
            
            // Draw wormhole structure
            drawWormholeStructure();
            
            // Draw wormhole center (dark void)
            const centerGradient = ctx.createRadialGradient(
                wormhole.x, wormhole.y, 0,
                wormhole.x, wormhole.y, wormhole.radius * 2
            );
            centerGradient.addColorStop(0, '#000');
            centerGradient.addColorStop(0.8, '#000');
            centerGradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');
            
            ctx.fillStyle = centerGradient;
            ctx.beginPath();
            ctx.arc(wormhole.x, wormhole.y, wormhole.radius * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Update and draw particles, remove dead ones
            for (let i = particles.length - 1; i >= 0; i--) {
                const isAlive = particles[i].update();
                
                if (isAlive) {
                    particles[i].draw();
                } else {
                    // Remove dead particle
                    particles.splice(i, 1);
                    particleCount--;
                }
            }
            
            // Draw interactive colored dots
            drawColoredDots();
            
            // Continue animation
            requestAnimationFrame(animate);
        }
        
        // Load profile images
        const profileImages = [];
        
        function loadProfileImages() {
            // Load each profile image from tweetsData
            tweetsData.forEach(tweet => {
                const img = new Image();
                img.src = tweet.profilePic;
                profileImages.push(img);
            });
        }
        
        // Create interactive profile image dots - one for each tweet
        function createColoredDots() {
            // Clear existing dots
            coloredDots.length = 0;
            
            // First, find the origin position (center of wormhole)
            const originX = wormhole.x;
            const originY = wormhole.y;
            const minDistanceFromOrigin = 150; // Minimum distance from origin in pixels
            
            // Determine base size based on screen size
            const isMobile = window.innerWidth < 768;
            const baseSizeDesktop = 18;
            const baseSizeMobile = 14; // Smaller on mobile
            const baseSize = isMobile ? baseSizeMobile : baseSizeDesktop;
            
            // Create one dot for each tweet in tweetsData
            for (let i = 0; i < tweetsData.length; i++) {
                const tweet = tweetsData[i];
                let x, y, size;
                
                // Determine size with some randomness
                const dotSize = baseSize + Math.random() * (isMobile ? 6 : 9);
                
                if (tweet.type === 'origin') {
                    // Position origin tweet at the center of the wormhole
                    x = originX;
                    y = originY;
                    size = dotSize * 1.7; // Origin is 1.7x larger
                } else {
                    // For non-origin tweets, ensure they're not too close to the origin
                    // and don't overlap with other dots
                    let isValidPosition = false;
                    let attempts = 0;
                    const maxAttempts = 100; // More attempts to find valid position
                    
                    while (!isValidPosition && attempts < maxAttempts) {
                        // Random position within the visible area with margins
                        const horizontalMargin = Math.max(100, canvas.width * 0.1); // At least 10% of width
                        const verticalMargin = Math.max(100, canvas.height * 0.1); // At least 10% of height
                        const footerMargin = 120; // Increased footer margin to avoid overlapping with logos
                        
                        // Calculate available height, ensuring we stay clear of the footer area
                        const availableHeight = canvas.height - footerMargin - verticalMargin;
                        
                        // If available height is too small, prioritize staying away from footer
                        const effectiveVerticalMargin = availableHeight < 300 ? 50 : verticalMargin;
                        
                        x = horizontalMargin + Math.random() * (canvas.width - 2 * horizontalMargin);
                        y = effectiveVerticalMargin + Math.random() * (availableHeight - effectiveVerticalMargin);
                        
                        // Additional check to ensure we're not in the footer area
                        if (y > canvas.height - footerMargin) {
                            y = canvas.height - footerMargin - dotSize * 3; // Keep well above footer
                        }
                        
                        // Calculate distance from origin
                        const dx = x - originX;
                        const dy = y - originY;
                        const distanceFromOrigin = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check if position is valid (not too close to origin)
                        let validDistance = distanceFromOrigin > minDistanceFromOrigin;
                        
                        // Check for overlap with existing dots
                        let noOverlap = true;
                        const minDistanceBetweenDots = dotSize * 2.5; // Minimum distance between dots
                        
                        for (let j = 0; j < coloredDots.length; j++) {
                            const otherDot = coloredDots[j];
                            const dxDot = x - otherDot.x;
                            const dyDot = y - otherDot.y;
                            const distanceBetweenDots = Math.sqrt(dxDot * dxDot + dyDot * dyDot);
                            
                            if (distanceBetweenDots < minDistanceBetweenDots) {
                                noOverlap = false;
                                break;
                            }
                        }
                        
                        // Position is valid if it's far enough from origin and doesn't overlap
                        isValidPosition = validDistance && noOverlap;
                        attempts++;
                    }
                    
                    // If we couldn't find a non-overlapping position after max attempts,
                    // just use the last position we tried
                    size = dotSize;
                }
                
                // Add dot with profile image
                coloredDots.push({
                    x: x,
                    y: y,
                    size: size,
                    pulsating: 0,
                    pulsateSpeed: 0.02 + Math.random() * 0.01,
                    imageIndex: i, // Each dot corresponds to exactly one tweet
                    isOrigin: tweet.type === 'origin' // Flag for special handling
                });
            }
        }
        
        // Draw the profile image dots
        function drawColoredDots() {
            // Only draw if images are loaded
            if (profileImages.length === 0) return;
            
            // Set image smoothing for better quality
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // First draw non-origin dots
            coloredDots.filter(dot => !dot.isOrigin).forEach(dot => {
                // Pulsating effect for the border only
                dot.pulsating += dot.pulsateSpeed;
                const pulseFactor = 1 + 0.1 * Math.sin(dot.pulsating);
                
                // Save context for clipping
                ctx.save();
                
                // Create circular clipping path that pulsates
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.size * pulseFactor, 0, Math.PI * 2);
                ctx.clip();
                
                // Draw the profile image at a fixed size (not affected by pulsation)
                // This prevents blurriness from constant resizing
                const img = profileImages[dot.imageIndex];
                const baseImgSize = dot.size * 2.2; // Slightly larger than the clip to avoid edge artifacts
                ctx.drawImage(img, dot.x - baseImgSize/2, dot.y - baseImgSize/2, baseImgSize, baseImgSize);
                
                // Restore context
                ctx.restore();
                
                // Add a thin white border for definition
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.size * pulseFactor, 0, Math.PI * 2);
                ctx.stroke();
            });
            
            // Then draw origin dots on top
            coloredDots.filter(dot => dot.isOrigin).forEach(dot => {
                // Keep origin dot at center if wormhole position changes
                dot.x = wormhole.x;
                dot.y = wormhole.y;
                
                // Stronger pulsating effect for origin (border only)
                dot.pulsating += dot.pulsateSpeed * 1.5;
                const pulseFactor = 1 + 0.02 * Math.sin(dot.pulsating);
                
                // Save context for clipping
                ctx.save();
                
                // Create circular clipping path
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.size * pulseFactor, 0, Math.PI * 2);
                ctx.clip();
                
                // Draw the profile image at a fixed size
                const img = profileImages[dot.imageIndex];
                const baseImgSize = dot.size * 2.2; // Slightly larger than the clip
                ctx.drawImage(img, dot.x - baseImgSize/2, dot.y - baseImgSize/2, baseImgSize, baseImgSize);
                
                // Restore context
                ctx.restore();
                
                // Add a subtle radiance glow for origin that doesn't interfere with the image
                
                // First, draw an outer glow that starts outside the image
                const outerGlow = ctx.createRadialGradient(
                    dot.x, dot.y, dot.size * pulseFactor * 1.1, // Start just outside the image
                    dot.x, dot.y, dot.size * pulseFactor * 2.2
                );
                outerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.2)'); // Reduced opacity
                outerGlow.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)'); // Reduced opacity
                outerGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.size * pulseFactor * 2.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Add a thin, bright ring around the image
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // Reduced opacity
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.size * pulseFactor * 1.05, 0, Math.PI * 2); // Just outside the image
                ctx.stroke();
                
                // Add a second, outer ring for distinction
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // Very subtle
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.arc(dot.x, dot.y, dot.size * pulseFactor * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            });
        }
        
        // Check if mouse is over a colored dot
        function checkDotHover(mouseX, mouseY) {
            for (let i = 0; i < coloredDots.length; i++) {
                const dot = coloredDots[i];
                const dx = mouseX - dot.x;
                const dy = mouseY - dot.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < dot.size * 1.5) {
                    return i; // Return index of hovered dot
                }
            }
            return -1; // No dot hovered
        }
        
        // Show tweet popup
        function showTweetPopup(dotIndex, mouseX, mouseY) {
            const popup = document.getElementById('tweetPopup');
            
            // Get tweet data for this dot
            // Each dot corresponds to exactly one tweet
            const tweet = tweetsData[dotIndex];
            
            // Populate tweet content from data
            document.getElementById('tweetProfilePic').src = tweet.profilePic;
            document.getElementById('tweetName').textContent = tweet.author;
            document.getElementById('tweetUsername').textContent = tweet.username;
            document.getElementById('tweetContent').textContent = tweet.content;
            document.getElementById('tweetTimestamp').textContent = tweet.timestamp;
            
            // Position popup near the dot but ensure it stays within viewport
            const popupWidth = Math.min(400, window.innerWidth - 40); // Responsive width
            const popupHeight = 180;
            
            // Get footer height to avoid overlapping
            const footerHeight = 80; // Same as footer-area height
            
            let left = mouseX + 20;
            let top = mouseY - popupHeight / 2;
            
            // Adjust if too close to right edge
            if (left + popupWidth > window.innerWidth) {
                left = Math.max(10, mouseX - popupWidth - 20);
            }
            
            // Adjust if too close to top/bottom edge
            if (top < 10) top = 10;
            if (top + popupHeight > window.innerHeight - footerHeight) {
                top = window.innerHeight - popupHeight - footerHeight;
            }
            
            // For mobile, center horizontally if screen is narrow
            if (window.innerWidth < 500) {
                left = (window.innerWidth - popupWidth) / 2;
            }
            
            // Set position and show popup
            popup.style.left = left + 'px';
            popup.style.top = top + 'px';
            popup.style.display = 'block';
        }
        
        // Hide tweet popup
        function hideTweetPopup() {
            const popup = document.getElementById('tweetPopup');
            popup.style.display = 'none';
        }
        
        // Mouse move event handler
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const hoveredDotIndex = checkDotHover(mouseX, mouseY);
            
            if (hoveredDotIndex >= 0) {
                canvas.style.cursor = 'pointer';
                showTweetPopup(hoveredDotIndex, e.clientX, e.clientY);
            } else {
                canvas.style.cursor = 'default';
                hideTweetPopup();
            }
        });
        
        // Mouse leave event handler
        canvas.addEventListener('mouseleave', () => {
            hideTweetPopup();
        });
        
        // Click event handler for opening tweet
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const hoveredDotIndex = checkDotHover(mouseX, mouseY);
            
            if (hoveredDotIndex >= 0) {
                // Get tweet data for this dot
                const tweet = tweetsData[hoveredDotIndex];
                window.open(tweet.url, '_blank');
            }
        });
        
        // Touch events for mobile support
        let touchTimer = null;
        let lastTouchX = 0;
        let lastTouchY = 0;
        
        // Touch start handler
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling when touching the canvas
            
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;
                
                const touchedDotIndex = checkDotHover(touchX, touchY);
                
                if (touchedDotIndex >= 0) {
                    // Show popup on touch
                    showTweetPopup(touchedDotIndex, touch.clientX, touch.clientY);
                    
                    // Set a timer to detect long press
                    touchTimer = setTimeout(() => {
                        // Long press - open the URL
                        const tweet = tweetsData[touchedDotIndex];
                        window.open(tweet.url, '_blank');
                        touchTimer = null;
                    }, 800); // 800ms for long press
                }
            }
        });
        
        // Touch end handler
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            
            // Clear the long press timer
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
            }
            
            // Hide popup after a short delay to allow for reading
            setTimeout(() => {
                hideTweetPopup();
            }, 1000);
        });
        
        // Touch move handler
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            // If moved too far, cancel the long press
            if (touchTimer && e.touches.length > 0) {
                const touch = e.touches[0];
                const dx = touch.clientX - lastTouchX;
                const dy = touch.clientY - lastTouchY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 10) { // If moved more than 10px
                    clearTimeout(touchTimer);
                    touchTimer = null;
                }
            }
        });
        
        
        // Initialize
        initParticles();
        loadProfileImages();
        
        // Create dots immediately
        createColoredDots();
        
        // Also ensure dots are recreated after window fully loads and on resize
        // This helps with positioning if window size changes
        window.addEventListener('load', () => {
            // Clear existing dots
            coloredDots.length = 0;
            // Create new dots
            createColoredDots();
        });
        
        // Recreate dots on window resize to ensure proper positioning
        window.addEventListener('resize', () => {
            // Wait a short moment for resize to complete
            setTimeout(() => {
                // Clear existing dots
                coloredDots.length = 0;
                // Create new dots with updated dimensions
                createColoredDots();
            }, 200);
        });
        
        // Start animation with timestamp
        requestAnimationFrame(animate);
    </script>
</body>
</html>
